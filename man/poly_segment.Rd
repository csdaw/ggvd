% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/poly_segment.R
\name{poly_segment}
\alias{poly_segment}
\title{Polygon segmentation}
\source{
Slightly modified from \code{eulerr::setup_geometry()} which is distributed
under the GPLv3 license.
}
\usage{
poly_segment(polys, tt)
}
\arguments{
\item{polys}{\verb{list of lists(x,y)} giving the coordinates of several polygons,
where \code{x} and \code{y} are numeric vectors giving the coordinates of the
vertices of a single polygon. The last vertex \strong{should not} repeat the
first vertex.}

\item{tt}{\verb{boolean matrix}, a truth-table describing which polygons are
involved in each potential segment. This matrix should have the same
number of columns as \code{length(polys)} and the same number of rows as
\code{2L^length(polys) - 1L}, i.e. 3 rows for 2 polygons or 7 rows for 3 polygons.}
}
\value{
Returns a \verb{list of lists(x,y)} with the coordinates of the resulting
segmented polygons.
}
\description{
This function will attempt to segment a list of polygons, if
any of them overlap.
}
\examples{
library(ggplot2)

e1 <- ellipse()
e2 <- ellipse(x0 = 0.5)

# Visualise before segmentation
ggplot(mapping = aes(x, y)) +
  geom_polygon(data = e1, fill = "red") +
  geom_polygon(data = e2, fill = "blue")

# Perform segmentation
truth_table <- matrix(
  c(TRUE, FALSE, TRUE,
    FALSE, TRUE, TRUE),
  ncol = 2,
  nrow = 3
)

segments <- poly_segment(list(as.list(e1), as.list(e2)), truth_table)

# Visualise after segmentation
segments_df <- do.call(rbind.data.frame, segments)
segments_df$segment_id <- sub("\\\\..*$", "", rownames(segments_df))
rownames(segments_df) <- NULL

ggplot(segments_df, aes(x, y, fill = segment_id)) +
  geom_polygon()

}
